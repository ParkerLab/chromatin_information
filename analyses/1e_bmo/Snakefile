#! /usr/bin/env python
#
# The Parker Lab (theparkerlab.org)
# University of Michigan, Ann Arbor
#

import itertools
import os
import sys
import functools
import math

from os.path import join


###
# GENERAL
#

# Data
BAM_SUB_DIR = config["bam_subsampled"]
MACS2_SUB_DIR = config["peaks_subsampled"]
MOTIF_DIR = config["motif_dir"]

# Path generator function
prefix_results = functools.partial(os.path.join, config['results'])

# Target directories (relative to root)
BMO_DIR = prefix_results('bmo')
CENTI_DIR = prefix_results('centipede')
CENTI_SB_DIR = prefix_results('centipede_singlebin')
D2TF_DIR = prefix_results('dnase2tf')
HINT_DIR = prefix_results('hint')
PIQ_DIR = prefix_results('piq')
PEAKS_DIR = prefix_results('motifs_in_atac-seq_peaks')
PEAKS2_DIR = prefix_results('motifs_in_atac-seq_peaks_scores')
CONCAT_DIR = prefix_results('concatenated_files')
COMPARE_DIR = prefix_results('comparisons')

# Logs
LOG_DIR = prefix_results('logs')
VERSION_DIR = prefix_results('versions')


###
# HELPER FUNCTIONS
#

def get_motifs():
    """List all motifs"""
    for motif in open(config['motif_file'], 'r').readlines():
        yield motif.strip()


def get_samples():
    """List all samples"""
    for sample in sorted(config['samples'].keys()):
        yield sample


def bam_from_sample(sample):
    """Return the bam file associated with a sample"""
    bamfile = config['samples'][sample]['bamfile']
    return bamfile


def subsampled_bam_from_sample(sample):
    """Return subsampling depths and fractions for a sample"""
    depth = config['samples'][sample]['depth'] / 10**6
    sub_depths = [5, 10]
    while sub_depths[-1] + 10 < depth:
        sub_depths.append(sub_depths[-1] + 10)
    sub_depths.append(math.floor(depth))
    bam_names = [os.path.join(
        BAM_SUB_DIR, "{}.{}M.bam"
        ).format(sample, x) for x in sub_depths]
    return bam_names


def subsampled_depths_from_sample(sample):
    """Return subsampling depths and fractions for a sample"""
    depth = config['samples'][sample]['depth'] / 10**6
    sub_depths = [5, 10]
    while sub_depths[-1] + 10 < depth:
        sub_depths.append(sub_depths[-1] + 10)
    sub_depths.append(math.floor(depth))
    return sub_depths
    # return [max(sub_depths)]  # only highest depth


def subsampled_bam_names_from_depth(sample, sub_depth):
    """Return subsampling depths and fractions for a sample"""
    bam_name = os.path.join(
        BAM_SUB_DIR, "{}.{}M.bam".format(sample, int(sub_depth))
    )
    return bam_name


def subsampled_bam_fraction_from_depth(sample, sub_depth):
    """Return subsampling depths and fractions for a sample"""
    depth = config['samples'][sample]['depth'] / 10**6
    fraction = sub_depth / depth
    return fraction


def get_piq_handle(motif):
    handle = motif_handle_dic[motif]
    return handle


def get_motif_index(motif):
    index = motif_dic[motif]
    return index

# Subsample dictionary - will be used to determine the output files for
# each sample
subsample_depths = {x: subsampled_depths_from_sample(x) for x in get_samples()}
# subsample_depths = {"buenrostro_rep1" : [80]} # debug

# Number of motifs and motif-number dictionary - used for PIQ
# e.g. 9-CTCFknown2, 20-NFKBknown10
all_motifs = [x for x in get_motifs()]
all_motifs.sort()
nmotifs = len(all_motifs)
motif_dic = {}
motif_handle_dic = {}
for i in range(0, nmotifs):
    motif = all_motifs[i]
    handle = "{}-{}".format(i + 1, all_motifs[i].replace("_", ""))
    motif_dic[motif] = str(i + 1)
    motif_handle_dic[motif] = handle



rule all:
    input:
        # Peak calls
        [expand(
            os.path.join(
                MACS2_SUB_DIR,
                "{sample}.{depth}_peaks.broadPeak.fdr0.05.noblacklist"
            ),
            sample=sample,
            depth=depths
        ) for sample, depths in subsample_depths.items()],
        
        # HINT
        [expand(
            os.path.join(
                HINT_DIR,
                "{sample}/motif_intersections/{motif}.{depth}.bed"
            ),
            sample=sample,
            depth=depths,
            motif=get_motifs()
        ) for sample, depths in subsample_depths.items()],
        
        # DNase2TF
        [expand(
            os.path.join(
                D2TF_DIR,
                "{sample}/motif_intersections/{motif}.{depth}.bed"
            ),
            sample=sample,
            depth=depths,
            motif=get_motifs()
        ) for sample, depths in subsample_depths.items()],
        
        # CENTIPEDE
        [expand(
            os.path.join(
                CENTI_DIR, "{sample}/posteriors/{motif}.{depth}.bed.gz"
            ),
            sample=sample,
            depth=depths,
            motif=get_motifs()
        ) for sample, depths in subsample_depths.items()],
        # CENTIPEDE single-bin
        [expand(
            os.path.join(
                CENTI_SB_DIR, "{sample}/posteriors/{motif}.{depth}.bed.gz"
            ),
            sample=sample,
            depth=depths,
            motif=get_motifs()
        ) for sample, depths in subsample_depths.items()],
        # BMO
        [expand(
            os.path.join(
                BMO_DIR, "{sample}", "bound", "{motif}.{depth}.bound.bed"
            ),
            sample=sample,
            depth=depths,
            motif=get_motifs()
        ) for sample, depths in subsample_depths.items()],
        
        # Motifs in peaks (binary)
        [expand(
            os.path.join(PEAKS_DIR, "{sample}", "{motif}.{depth}.bed"),
            sample=sample,
            depth=depths,
            motif=get_motifs()
        ) for sample, depths in subsample_depths.items()],

        # Motifs in peaks (with -log10 pval)
        [expand(
            os.path.join(PEAKS2_DIR, "{sample}", "{motif}.{depth}.bed"),
            sample=sample,
            depth=depths,
            motif=get_motifs()
        ) for sample, depths in subsample_depths.items()],
        
rule all_piq:
    input:
        # PIQ - binarized files
        [expand(
            os.path.join(
                PIQ_DIR,
                "processed_output_binary", "{sample}", "{depth}M.{motif}.bed"
            ),
            sample=sample,
            depth=depths,
            motif=get_motifs()
        ) for sample, depths in subsample_depths.items()],
        # PIQ - scores files
        [expand(
            os.path.join(
                PIQ_DIR,
                "processed_output_scores", "{sample}", "{depth}M.{motif}.bed"
            ),
            sample=sample,
            depth=depths,
            motif=get_motifs()
        ) for sample, depths in subsample_depths.items()],

rule all_evaluate:
    input:
        [expand(
            os.path.join(CONCAT_DIR, "{sample}/{motif}.{depth}.bed"),
            sample=sample,
            depth=depths, motif=get_motifs()
        ) for sample, depths in subsample_depths.items()],
        
        expand(
            prefix_results("f1/{sample}/get_f1.ok"), sample=get_samples()
        ),
        expand(
            prefix_results("roc/{sample}/get_roc.ok"), sample=get_samples()
        ),


rule all_aggregate:
    input:
        expand(
            prefix_results("roc/{sample}/prauc_data.txt"), sample=get_samples()
        ),
        expand(
            prefix_results("roc/{sample}/roc_data.txt"), sample=get_samples()
        ),
        expand(
            prefix_results("f1/{sample}/f1_data.txt"), sample=get_samples()
        )



# Get motifs in peaks
rule blacklist_filter:
    output:
        os.path.join(
            MACS2_SUB_DIR,
            "{sample}.{depth}_peaks.broadPeak.fdr0.05.noblacklist"
        )

rule motifs_in_peaks:
    input:
        motif = lambda wildcards: "{}/{}.bed.gz".format(
            config['motif_dir'], wildcards.motif),
        peaks = rules.blacklist_filter.output
    output:
        os.path.join(PEAKS_DIR, "{sample}/{motif}.{depth}.bed")
    resources:
        io_limit = 1
    shell:
        """
        ionice -c2 -n7 intersectBed -f 1.0 -loj -a {input.motif} \
            -b {input.peaks} | cut -f 1-7 | \
            awk '{{OFS="\\t"; if($7 == ".")\
            {{print $1,$2,$3,$4,$5,$6,0}}else{{print $1,$2,$3,$4,$5,$6,1}}}}'\
            > {output}
        """

rule motifs_in_peaks2:
    input:
        motif = lambda wildcards: "{}/{}.bed.gz".format(
            config['motif_dir'], wildcards.motif),
        peaks = rules.blacklist_filter.output
    output:
        os.path.join(PEAKS2_DIR, "{sample}/{motif}.{depth}.bed")
    resources:
        io_limit = 1
    shell:
        """
        ionice -c2 -n7 intersectBed -f 1.0 -loj -a {input.motif} \
            -b {input.peaks} | cut -f 1-6,14 | \
            sed 's/\\.$/0/g' > {output}
        """

# Run TF-binding prediction methods
include: "rules/tf-binding_hint.smk"
include: "rules/tf-binding_dnase2tf.smk"
include: "rules/tf-binding_centipede.smk"
include: "rules/tf-binding_bmo.smk"
include: "rules/tf-binding_centipede_singlebin.smk"
include: "rules/tf-binding_piq.smk" 

# # Compare methods
include: "rules/tf-binding_evaluate.smk"